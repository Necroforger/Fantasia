package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

var moduleTmpl = template.Must(template.New("registerModules").Funcs(template.FuncMap{
	"title": strings.Title,
}).Parse(`package main

import (
	"log"

	{{range . -}}
	"github.com/Necroforger/Fantasia/modules/{{.Name}}"
	{{end}}
	"github.com/Necroforger/Fantasia/system"
)

////////////////////////////////////////////
//            Generated by
//          tools/genmodules
////////////////////////////////////////////

// ModuleConfig ...
type ModuleConfig struct {
	Inverted bool
	{{range . -}}
	{{title .Name}} bool
	{{end}}

	{{range . -}}{{if .HasConfig -}}
	{{title .Name}}Config *{{.Name}}.Config
	{{end}}{{end}}
}

// NewModuleConfig returns a new module configuration
func NewModuleConfig() ModuleConfig {
	return ModuleConfig{
		Inverted: false,
		{{range . -}}
		{{title .Name}}: true,
		{{end}}

		{{range . -}}{{if .HasConfig -}}
		{{title .Name}}Config: {{.Name}}.NewConfig(),
		{{end}}{{end}}
	}
}

// RegisterModules builds a list of modules into the given system
func RegisterModules(s *system.System, config ModuleConfig) {
	{{range . -}}
	if (config.Inverted && !config.{{title .Name}}) || (!config.Inverted && config.{{title .Name}}) {
		s.CommandRouter.SetCategory("{{title .Name}}")
		{{- if .HasConfig}}
		if config.{{title .Name}}Config != nil {
			s.BuildModule(&{{.Name}}.Module{Config: config.{{title .Name}}Config })
		} else {
			s.BuildModule(&{{.Name}}.Module{Config: {{.Name}}.NewConfig()})
		}
		{{else}}
		s.BuildModule(&{{.Name}}.Module{})
		{{end -}}
		log.Println("loaded {{.Name}} module...")
	}
	{{end}}
}

`))

// ModuleList ...
type ModuleList struct {
	HasConfig bool
	Name      string
}

// ModuleListByNames ...
type ModuleListByNames []ModuleList

// Len ...
func (m ModuleListByNames) Len() int {
	return len(m)
}

// Less ...
func (m ModuleListByNames) Less(a, b int) bool {
	return m[a].Name < m[b].Name
}

// Swap ...
func (m ModuleListByNames) Swap(a, b int) {
	m[a], m[b] = m[b], m[a]
}

func main() {
	var (
		output     bytes.Buffer
		currentDir = filepath.Dir(".")
	)

	modules, err := ioutil.ReadDir("modules")
	if err != nil {
		fmt.Println("error: modules folder does not exist")
		return
	}

	moduleList := []ModuleList{}
	for _, v := range modules {
		moduleList = append(moduleList,
			ModuleList{false, v.Name()})
	}

	// Scan over all the main package files to see if they have a Configuration available.
	for i, v := range modules {
		data, err := ioutil.ReadFile(filepath.Join(currentDir, "modules", v.Name(), v.Name()+".go"))
		if err != nil {
			fmt.Println(err)
			continue
		}

		// Check if the file meets all the requirements for having a config
		if regexp.MustCompile("(?m:^//genmodules:config)").MatchString(string(data)) &&
			regexp.MustCompile("(?m:^type Config struct)").MatchString(string(data)) &&
			regexp.MustCompile(`(?m:^func NewConfig())`).MatchString(string(data)) {

			moduleList[i].HasConfig = true
		}
	}

	fmt.Println(moduleList)

	sort.Sort(ModuleListByNames(moduleList))
	err = moduleTmpl.Execute(&output, moduleList)
	if err != nil {
		fmt.Println("error: template failed to execute", err)
		return
	}

	src, err := format.Source(output.Bytes())
	if err != nil {
		fmt.Println("error: invalid Go generated", err)
		fmt.Println(string(output.Bytes()))
		return
	}

	err = ioutil.WriteFile(filepath.Join(currentDir, "register_modules.go"), src, 0644)
	if err != nil {
		fmt.Println("error: failed to output file: ", err)
	}

}
